Analytic

Notes about the analytic script:

t0 is chosen on order 
ğ‘‘
ğ‘¥
2
/
ğœ
2
dx
2
/Ïƒ
2
 so the initial Gaussian is resolved.

We evaluate coefficients at current time t (a common simple implicit choice). For better accuracy you could evaluate at t+dt.

The tridiagonal assembly uses a conservative-style discretization; it's stable for implicit Euler and cheap (Thomas algorithm).

After each implicit step we floor negatives and renormalize, then shift the density to exactly match the forward 
ğ¹
(
ğ‘¡
)
=
ğ‘†
0
ğ‘’
(
ğ‘Ÿ
âˆ’
ğ‘
)
ğ‘¡
F(t)=S
0
	â€‹

e
(râˆ’q)t
. Shifting is done by interpolation in log-space (keeps positivity if interpolation doesn't overshoot).

Mollifier

Practical notes, caveats and tuning suggestions

Finite-difference vs finite-volume / SG: the FD scheme above is straightforward and implicit-stable, but if you need very strong positivity guarantees and sharper handling of drift-dominated regimes, replace the advection/diffusion flux discretization with Scharfetterâ€“Gummel (finite-volume) â€” itâ€™s a drop-in flux modification but requires slightly different matrix assembly.

Matching forward by shifting: we match the forward exactly by translating the density in 
ğ‘¥
x. This preserves shape but may slightly move mass into boundaries if domain too small â€” ensure domain is wide enough. Alternatively, you can apply an exponential tilt, but shifting is simpler and robust.

Flooring negatives: clipping to zero and renormalizing is a pragmatic fix; if negative mass becomes large, reduce dt or use more robust positivity-preserving spatial discretization.

t0 selection for analytic: the analytic initialization should use small 
ğ‘¡
0
t
0
	â€‹

 that yields a Gaussian resolved on the grid. I used a rule ~ 
ğ‘‘
ğ‘¥
2
/
ğœ
2
dx
2
/Ïƒ
2
. You can increase t0 to decrease stiffness at early times if needed.

Time stepping: implicit Euler is first-order in time but monotone and robust. After the transient you can swap to Crankâ€“Nicolson for second-order time accuracy, but watch for possible small undershoots (clip/limit).

Boundary conditions: code uses simple one-sided approximations to impose reflecting (zero-flux). If you want absorbing boundaries, change boundary rows appropriately.

Interpolation aliasing: the shift via np.interp is linear interpolation; it is simple and good provided your grid is fine enough. If you prefer higher-order interpolation use scipy.interpolate.interp1d(kind='cubic') (but be careful of overshoot).